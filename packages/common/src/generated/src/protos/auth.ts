// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: src/protos/auth.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";

export enum VerificationType {
  VERIFICATION_TYPE_UNSPECIFIED = 0,
  VERIFICATION_TYPE_EMAIL = 1,
  VERIFICATION_TYPE_PHONE = 2,
  UNRECOGNIZED = -1,
}

export function verificationTypeFromJSON(object: any): VerificationType {
  switch (object) {
    case 0:
    case "VERIFICATION_TYPE_UNSPECIFIED":
      return VerificationType.VERIFICATION_TYPE_UNSPECIFIED;
    case 1:
    case "VERIFICATION_TYPE_EMAIL":
      return VerificationType.VERIFICATION_TYPE_EMAIL;
    case 2:
    case "VERIFICATION_TYPE_PHONE":
      return VerificationType.VERIFICATION_TYPE_PHONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerificationType.UNRECOGNIZED;
  }
}

export function verificationTypeToJSON(object: VerificationType): string {
  switch (object) {
    case VerificationType.VERIFICATION_TYPE_UNSPECIFIED:
      return "VERIFICATION_TYPE_UNSPECIFIED";
    case VerificationType.VERIFICATION_TYPE_EMAIL:
      return "VERIFICATION_TYPE_EMAIL";
    case VerificationType.VERIFICATION_TYPE_PHONE:
      return "VERIFICATION_TYPE_PHONE";
    case VerificationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TwoFactorType {
  TWO_FACTOR_TYPE_UNSPECIFIED = 0,
  /** TWO_FACTOR_TYPE_TOTP - Authenticator app (Time-based OTP) */
  TWO_FACTOR_TYPE_TOTP = 1,
  /** TWO_FACTOR_TYPE_EMAIL_OTP - Email one-time code */
  TWO_FACTOR_TYPE_EMAIL_OTP = 2,
  /** TWO_FACTOR_TYPE_SMS_OTP - SMS one-time code */
  TWO_FACTOR_TYPE_SMS_OTP = 3,
  UNRECOGNIZED = -1,
}

export function twoFactorTypeFromJSON(object: any): TwoFactorType {
  switch (object) {
    case 0:
    case "TWO_FACTOR_TYPE_UNSPECIFIED":
      return TwoFactorType.TWO_FACTOR_TYPE_UNSPECIFIED;
    case 1:
    case "TWO_FACTOR_TYPE_TOTP":
      return TwoFactorType.TWO_FACTOR_TYPE_TOTP;
    case 2:
    case "TWO_FACTOR_TYPE_EMAIL_OTP":
      return TwoFactorType.TWO_FACTOR_TYPE_EMAIL_OTP;
    case 3:
    case "TWO_FACTOR_TYPE_SMS_OTP":
      return TwoFactorType.TWO_FACTOR_TYPE_SMS_OTP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TwoFactorType.UNRECOGNIZED;
  }
}

export function twoFactorTypeToJSON(object: TwoFactorType): string {
  switch (object) {
    case TwoFactorType.TWO_FACTOR_TYPE_UNSPECIFIED:
      return "TWO_FACTOR_TYPE_UNSPECIFIED";
    case TwoFactorType.TWO_FACTOR_TYPE_TOTP:
      return "TWO_FACTOR_TYPE_TOTP";
    case TwoFactorType.TWO_FACTOR_TYPE_EMAIL_OTP:
      return "TWO_FACTOR_TYPE_EMAIL_OTP";
    case TwoFactorType.TWO_FACTOR_TYPE_SMS_OTP:
      return "TWO_FACTOR_TYPE_SMS_OTP";
    case TwoFactorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TwoFactorDeliveryMethod {
  TWO_FACTOR_DELIVERY_UNSPECIFIED = 0,
  TWO_FACTOR_DELIVERY_AUTHENTICATOR = 1,
  TWO_FACTOR_DELIVERY_EMAIL = 2,
  TWO_FACTOR_DELIVERY_SMS = 3,
  UNRECOGNIZED = -1,
}

export function twoFactorDeliveryMethodFromJSON(object: any): TwoFactorDeliveryMethod {
  switch (object) {
    case 0:
    case "TWO_FACTOR_DELIVERY_UNSPECIFIED":
      return TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_UNSPECIFIED;
    case 1:
    case "TWO_FACTOR_DELIVERY_AUTHENTICATOR":
      return TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_AUTHENTICATOR;
    case 2:
    case "TWO_FACTOR_DELIVERY_EMAIL":
      return TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_EMAIL;
    case 3:
    case "TWO_FACTOR_DELIVERY_SMS":
      return TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_SMS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TwoFactorDeliveryMethod.UNRECOGNIZED;
  }
}

export function twoFactorDeliveryMethodToJSON(object: TwoFactorDeliveryMethod): string {
  switch (object) {
    case TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_UNSPECIFIED:
      return "TWO_FACTOR_DELIVERY_UNSPECIFIED";
    case TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_AUTHENTICATOR:
      return "TWO_FACTOR_DELIVERY_AUTHENTICATOR";
    case TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_EMAIL:
      return "TWO_FACTOR_DELIVERY_EMAIL";
    case TwoFactorDeliveryMethod.TWO_FACTOR_DELIVERY_SMS:
      return "TWO_FACTOR_DELIVERY_SMS";
    case TwoFactorDeliveryMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuthTokens {
  sessionId: string;
  accessToken: string;
  refreshToken: string;
  accessTokenExpiresAt: Date | undefined;
  refreshTokenExpiresAt:
    | Date
    | undefined;
  /** "Bearer" */
  tokenType: string;
}

export interface LoginRequest {
  /** email / phone / username */
  identifier: string;
  password: string;
  /** Optional for initial login */
  twoFactorCode?:
    | string
    | undefined;
  /** For 2FA continuation */
  twoFactorSessionId?: string | undefined;
}

export interface LoginResponse {
  authSuccess?: AuthSuccess | undefined;
  twoFactorRequired?: TwoFactorRequired | undefined;
}

export interface AuthSuccess {
  tokens: AuthTokens | undefined;
  user: UserInfo | undefined;
}

export interface TwoFactorRequired {
  message: string;
  /** Temporary session for 2FA verification */
  twoFactorSessionId: string;
  type: TwoFactorType;
  deliveryMethod: TwoFactorDeliveryMethod;
  /** "us***@ex***.com", "+1******7890" */
  maskedTarget: string;
  expiresAt:
    | Date
    | undefined;
  /** 6 for TOTP, 6 for OTPs */
  codeLength: number;
  canResend: boolean;
  resendAfter: Date | undefined;
}

export interface Verify2FARequest {
  twoFactorSessionId: string;
  code: string;
  type: TwoFactorType;
}

export interface SignupRequest {
  name: string;
  email: string;
  password: string;
  phone?: string | undefined;
  acceptTerms?: boolean | undefined;
  referralCode?: string | undefined;
}

export interface SignupResponse {
  message: string;
  userId: string;
  email: string;
  createdAt: Date | undefined;
  verificationRequired: boolean;
  verificationType: VerificationType;
}

export interface Enable2FARequest {
  type: TwoFactorType;
  email?: string | undefined;
  phone?: string | undefined;
}

export interface Enable2FAResponse {
  /** For TOTP - base32 secret */
  secret: string;
  /** For TOTP - QR code URL */
  qrCodeUrl: string;
  /** For TOTP - manual entry code */
  manualEntryCode: string;
  type: TwoFactorType;
  deliveryTarget: string;
  expiresAt: Date | undefined;
}

export interface Disable2FARequest {
  /** Require password confirmation */
  password: string;
  /** If 2FA is currently enabled */
  twoFactorCode?: string | undefined;
}

export interface Verify2FASetupRequest {
  code: string;
  type: TwoFactorType;
}

export interface UserInfo {
  userId: string;
  name: string;
  email: string;
  phone?: string | undefined;
  avatarUrl: string;
  emailVerified: boolean;
  phoneVerified: boolean;
  twoFactorEnabled: boolean;
  twoFactorType: TwoFactorType;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  lastLoginAt: Date | undefined;
}

export interface SessionInfo {
  user: UserInfo | undefined;
  sessionId: string;
  deviceInfo: string;
  ipAddress: string;
  userAgent: string;
  issuedAt: Date | undefined;
  expiresAt: Date | undefined;
  isMfaAuthenticated: boolean;
  permissions: string[];
  metadata: { [key: string]: string };
}

export interface SessionInfo_MetadataEntry {
  key: string;
  value: string;
}

export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
  /** If 2FA is enabled */
  twoFactorCode?: string | undefined;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  token: string;
  newPassword: string;
}

export interface VerifyAccountRequest {
  token: string;
  type: VerificationType;
}

export interface ResendVerificationRequest {
  type: VerificationType;
  email?: string | undefined;
  phone?: string | undefined;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface DeviceInfo {
  deviceId: string;
  name: string;
  /** "web", "ios", "android", "desktop" */
  type: string;
  os: string;
  browser: string;
  lastActive: Date | undefined;
  isCurrent: boolean;
}

export interface GetDevicesResponse {
  devices: DeviceInfo[];
}

export interface RevokeDeviceRequest {
  deviceId: string;
}

export interface SecurityEvent {
  eventId: string;
  /** "login", "password_change", "2fa_enabled", etc. */
  type: string;
  description: string;
  ipAddress: string;
  userAgent: string;
  occurredAt: Date | undefined;
  metadata: { [key: string]: string };
}

export interface SecurityEvent_MetadataEntry {
  key: string;
  value: string;
}

export interface GetSecurityEventsRequest {
  page: number;
  pageSize: number;
  fromDate: Date | undefined;
  toDate: Date | undefined;
}

export interface GetSecurityEventsResponse {
  events: SecurityEvent[];
  total: number;
  page: number;
  pageSize: number;
}

export interface GenericMessage {
  message: string;
  details: { [key: string]: string };
}

export interface GenericMessage_DetailsEntry {
  key: string;
  value: string;
}

function createBaseAuthTokens(): AuthTokens {
  return {
    sessionId: "",
    accessToken: "",
    refreshToken: "",
    accessTokenExpiresAt: undefined,
    refreshTokenExpiresAt: undefined,
    tokenType: "",
  };
}

export const AuthTokens: MessageFns<AuthTokens> = {
  encode(message: AuthTokens, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.accessToken !== "") {
      writer.uint32(18).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(26).string(message.refreshToken);
    }
    if (message.accessTokenExpiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.accessTokenExpiresAt), writer.uint32(34).fork()).join();
    }
    if (message.refreshTokenExpiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.refreshTokenExpiresAt), writer.uint32(42).fork()).join();
    }
    if (message.tokenType !== "") {
      writer.uint32(50).string(message.tokenType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthTokens {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthTokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.accessTokenExpiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.refreshTokenExpiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthTokens {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      accessTokenExpiresAt: isSet(object.accessTokenExpiresAt)
        ? fromJsonTimestamp(object.accessTokenExpiresAt)
        : undefined,
      refreshTokenExpiresAt: isSet(object.refreshTokenExpiresAt)
        ? fromJsonTimestamp(object.refreshTokenExpiresAt)
        : undefined,
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
    };
  },

  toJSON(message: AuthTokens): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.accessTokenExpiresAt !== undefined) {
      obj.accessTokenExpiresAt = message.accessTokenExpiresAt.toISOString();
    }
    if (message.refreshTokenExpiresAt !== undefined) {
      obj.refreshTokenExpiresAt = message.refreshTokenExpiresAt.toISOString();
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthTokens>, I>>(base?: I): AuthTokens {
    return AuthTokens.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthTokens>, I>>(object: I): AuthTokens {
    const message = createBaseAuthTokens();
    message.sessionId = object.sessionId ?? "";
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.accessTokenExpiresAt = object.accessTokenExpiresAt ?? undefined;
    message.refreshTokenExpiresAt = object.refreshTokenExpiresAt ?? undefined;
    message.tokenType = object.tokenType ?? "";
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { identifier: "", password: "", twoFactorCode: undefined, twoFactorSessionId: undefined };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.twoFactorCode !== undefined) {
      writer.uint32(26).string(message.twoFactorCode);
    }
    if (message.twoFactorSessionId !== undefined) {
      writer.uint32(34).string(message.twoFactorSessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.twoFactorCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.twoFactorSessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      twoFactorCode: isSet(object.twoFactorCode) ? globalThis.String(object.twoFactorCode) : undefined,
      twoFactorSessionId: isSet(object.twoFactorSessionId) ? globalThis.String(object.twoFactorSessionId) : undefined,
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.twoFactorCode !== undefined) {
      obj.twoFactorCode = message.twoFactorCode;
    }
    if (message.twoFactorSessionId !== undefined) {
      obj.twoFactorSessionId = message.twoFactorSessionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.identifier = object.identifier ?? "";
    message.password = object.password ?? "";
    message.twoFactorCode = object.twoFactorCode ?? undefined;
    message.twoFactorSessionId = object.twoFactorSessionId ?? undefined;
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { authSuccess: undefined, twoFactorRequired: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authSuccess !== undefined) {
      AuthSuccess.encode(message.authSuccess, writer.uint32(10).fork()).join();
    }
    if (message.twoFactorRequired !== undefined) {
      TwoFactorRequired.encode(message.twoFactorRequired, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authSuccess = AuthSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.twoFactorRequired = TwoFactorRequired.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      authSuccess: isSet(object.authSuccess) ? AuthSuccess.fromJSON(object.authSuccess) : undefined,
      twoFactorRequired: isSet(object.twoFactorRequired)
        ? TwoFactorRequired.fromJSON(object.twoFactorRequired)
        : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.authSuccess !== undefined) {
      obj.authSuccess = AuthSuccess.toJSON(message.authSuccess);
    }
    if (message.twoFactorRequired !== undefined) {
      obj.twoFactorRequired = TwoFactorRequired.toJSON(message.twoFactorRequired);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.authSuccess = (object.authSuccess !== undefined && object.authSuccess !== null)
      ? AuthSuccess.fromPartial(object.authSuccess)
      : undefined;
    message.twoFactorRequired = (object.twoFactorRequired !== undefined && object.twoFactorRequired !== null)
      ? TwoFactorRequired.fromPartial(object.twoFactorRequired)
      : undefined;
    return message;
  },
};

function createBaseAuthSuccess(): AuthSuccess {
  return { tokens: undefined, user: undefined };
}

export const AuthSuccess: MessageFns<AuthSuccess> = {
  encode(message: AuthSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokens !== undefined) {
      AuthTokens.encode(message.tokens, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tokens = AuthTokens.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthSuccess {
    return {
      tokens: isSet(object.tokens) ? AuthTokens.fromJSON(object.tokens) : undefined,
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: AuthSuccess): unknown {
    const obj: any = {};
    if (message.tokens !== undefined) {
      obj.tokens = AuthTokens.toJSON(message.tokens);
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthSuccess>, I>>(base?: I): AuthSuccess {
    return AuthSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthSuccess>, I>>(object: I): AuthSuccess {
    const message = createBaseAuthSuccess();
    message.tokens = (object.tokens !== undefined && object.tokens !== null)
      ? AuthTokens.fromPartial(object.tokens)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseTwoFactorRequired(): TwoFactorRequired {
  return {
    message: "",
    twoFactorSessionId: "",
    type: 0,
    deliveryMethod: 0,
    maskedTarget: "",
    expiresAt: undefined,
    codeLength: 0,
    canResend: false,
    resendAfter: undefined,
  };
}

export const TwoFactorRequired: MessageFns<TwoFactorRequired> = {
  encode(message: TwoFactorRequired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.twoFactorSessionId !== "") {
      writer.uint32(18).string(message.twoFactorSessionId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.deliveryMethod !== 0) {
      writer.uint32(32).int32(message.deliveryMethod);
    }
    if (message.maskedTarget !== "") {
      writer.uint32(42).string(message.maskedTarget);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(50).fork()).join();
    }
    if (message.codeLength !== 0) {
      writer.uint32(56).int32(message.codeLength);
    }
    if (message.canResend !== false) {
      writer.uint32(64).bool(message.canResend);
    }
    if (message.resendAfter !== undefined) {
      Timestamp.encode(toTimestamp(message.resendAfter), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TwoFactorRequired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTwoFactorRequired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.twoFactorSessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deliveryMethod = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maskedTarget = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.codeLength = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.canResend = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resendAfter = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TwoFactorRequired {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      twoFactorSessionId: isSet(object.twoFactorSessionId) ? globalThis.String(object.twoFactorSessionId) : "",
      type: isSet(object.type) ? twoFactorTypeFromJSON(object.type) : 0,
      deliveryMethod: isSet(object.deliveryMethod) ? twoFactorDeliveryMethodFromJSON(object.deliveryMethod) : 0,
      maskedTarget: isSet(object.maskedTarget) ? globalThis.String(object.maskedTarget) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      codeLength: isSet(object.codeLength) ? globalThis.Number(object.codeLength) : 0,
      canResend: isSet(object.canResend) ? globalThis.Boolean(object.canResend) : false,
      resendAfter: isSet(object.resendAfter) ? fromJsonTimestamp(object.resendAfter) : undefined,
    };
  },

  toJSON(message: TwoFactorRequired): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.twoFactorSessionId !== "") {
      obj.twoFactorSessionId = message.twoFactorSessionId;
    }
    if (message.type !== 0) {
      obj.type = twoFactorTypeToJSON(message.type);
    }
    if (message.deliveryMethod !== 0) {
      obj.deliveryMethod = twoFactorDeliveryMethodToJSON(message.deliveryMethod);
    }
    if (message.maskedTarget !== "") {
      obj.maskedTarget = message.maskedTarget;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.codeLength !== 0) {
      obj.codeLength = Math.round(message.codeLength);
    }
    if (message.canResend !== false) {
      obj.canResend = message.canResend;
    }
    if (message.resendAfter !== undefined) {
      obj.resendAfter = message.resendAfter.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TwoFactorRequired>, I>>(base?: I): TwoFactorRequired {
    return TwoFactorRequired.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TwoFactorRequired>, I>>(object: I): TwoFactorRequired {
    const message = createBaseTwoFactorRequired();
    message.message = object.message ?? "";
    message.twoFactorSessionId = object.twoFactorSessionId ?? "";
    message.type = object.type ?? 0;
    message.deliveryMethod = object.deliveryMethod ?? 0;
    message.maskedTarget = object.maskedTarget ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    message.codeLength = object.codeLength ?? 0;
    message.canResend = object.canResend ?? false;
    message.resendAfter = object.resendAfter ?? undefined;
    return message;
  },
};

function createBaseVerify2FARequest(): Verify2FARequest {
  return { twoFactorSessionId: "", code: "", type: 0 };
}

export const Verify2FARequest: MessageFns<Verify2FARequest> = {
  encode(message: Verify2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.twoFactorSessionId !== "") {
      writer.uint32(10).string(message.twoFactorSessionId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Verify2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerify2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.twoFactorSessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Verify2FARequest {
    return {
      twoFactorSessionId: isSet(object.twoFactorSessionId) ? globalThis.String(object.twoFactorSessionId) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      type: isSet(object.type) ? twoFactorTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Verify2FARequest): unknown {
    const obj: any = {};
    if (message.twoFactorSessionId !== "") {
      obj.twoFactorSessionId = message.twoFactorSessionId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.type !== 0) {
      obj.type = twoFactorTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Verify2FARequest>, I>>(base?: I): Verify2FARequest {
    return Verify2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Verify2FARequest>, I>>(object: I): Verify2FARequest {
    const message = createBaseVerify2FARequest();
    message.twoFactorSessionId = object.twoFactorSessionId ?? "";
    message.code = object.code ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSignupRequest(): SignupRequest {
  return { name: "", email: "", password: "", phone: undefined, acceptTerms: undefined, referralCode: undefined };
}

export const SignupRequest: MessageFns<SignupRequest> = {
  encode(message: SignupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.acceptTerms !== undefined) {
      writer.uint32(40).bool(message.acceptTerms);
    }
    if (message.referralCode !== undefined) {
      writer.uint32(50).string(message.referralCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.acceptTerms = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.referralCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      acceptTerms: isSet(object.acceptTerms) ? globalThis.Boolean(object.acceptTerms) : undefined,
      referralCode: isSet(object.referralCode) ? globalThis.String(object.referralCode) : undefined,
    };
  },

  toJSON(message: SignupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.acceptTerms !== undefined) {
      obj.acceptTerms = message.acceptTerms;
    }
    if (message.referralCode !== undefined) {
      obj.referralCode = message.referralCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupRequest>, I>>(base?: I): SignupRequest {
    return SignupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupRequest>, I>>(object: I): SignupRequest {
    const message = createBaseSignupRequest();
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.phone = object.phone ?? undefined;
    message.acceptTerms = object.acceptTerms ?? undefined;
    message.referralCode = object.referralCode ?? undefined;
    return message;
  },
};

function createBaseSignupResponse(): SignupResponse {
  return { message: "", userId: "", email: "", createdAt: undefined, verificationRequired: false, verificationType: 0 };
}

export const SignupResponse: MessageFns<SignupResponse> = {
  encode(message: SignupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.verificationRequired !== false) {
      writer.uint32(40).bool(message.verificationRequired);
    }
    if (message.verificationType !== 0) {
      writer.uint32(48).int32(message.verificationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.verificationRequired = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.verificationType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignupResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      verificationRequired: isSet(object.verificationRequired)
        ? globalThis.Boolean(object.verificationRequired)
        : false,
      verificationType: isSet(object.verificationType) ? verificationTypeFromJSON(object.verificationType) : 0,
    };
  },

  toJSON(message: SignupResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.verificationRequired !== false) {
      obj.verificationRequired = message.verificationRequired;
    }
    if (message.verificationType !== 0) {
      obj.verificationType = verificationTypeToJSON(message.verificationType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignupResponse>, I>>(base?: I): SignupResponse {
    return SignupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignupResponse>, I>>(object: I): SignupResponse {
    const message = createBaseSignupResponse();
    message.message = object.message ?? "";
    message.userId = object.userId ?? "";
    message.email = object.email ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.verificationRequired = object.verificationRequired ?? false;
    message.verificationType = object.verificationType ?? 0;
    return message;
  },
};

function createBaseEnable2FARequest(): Enable2FARequest {
  return { type: 0, email: undefined, phone: undefined };
}

export const Enable2FARequest: MessageFns<Enable2FARequest> = {
  encode(message: Enable2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.email !== undefined) {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(26).string(message.phone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Enable2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnable2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Enable2FARequest {
    return {
      type: isSet(object.type) ? twoFactorTypeFromJSON(object.type) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
    };
  },

  toJSON(message: Enable2FARequest): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = twoFactorTypeToJSON(message.type);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Enable2FARequest>, I>>(base?: I): Enable2FARequest {
    return Enable2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Enable2FARequest>, I>>(object: I): Enable2FARequest {
    const message = createBaseEnable2FARequest();
    message.type = object.type ?? 0;
    message.email = object.email ?? undefined;
    message.phone = object.phone ?? undefined;
    return message;
  },
};

function createBaseEnable2FAResponse(): Enable2FAResponse {
  return { secret: "", qrCodeUrl: "", manualEntryCode: "", type: 0, deliveryTarget: "", expiresAt: undefined };
}

export const Enable2FAResponse: MessageFns<Enable2FAResponse> = {
  encode(message: Enable2FAResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret !== "") {
      writer.uint32(10).string(message.secret);
    }
    if (message.qrCodeUrl !== "") {
      writer.uint32(18).string(message.qrCodeUrl);
    }
    if (message.manualEntryCode !== "") {
      writer.uint32(26).string(message.manualEntryCode);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.deliveryTarget !== "") {
      writer.uint32(42).string(message.deliveryTarget);
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Enable2FAResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnable2FAResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.secret = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.qrCodeUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.manualEntryCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.deliveryTarget = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Enable2FAResponse {
    return {
      secret: isSet(object.secret) ? globalThis.String(object.secret) : "",
      qrCodeUrl: isSet(object.qrCodeUrl) ? globalThis.String(object.qrCodeUrl) : "",
      manualEntryCode: isSet(object.manualEntryCode) ? globalThis.String(object.manualEntryCode) : "",
      type: isSet(object.type) ? twoFactorTypeFromJSON(object.type) : 0,
      deliveryTarget: isSet(object.deliveryTarget) ? globalThis.String(object.deliveryTarget) : "",
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
    };
  },

  toJSON(message: Enable2FAResponse): unknown {
    const obj: any = {};
    if (message.secret !== "") {
      obj.secret = message.secret;
    }
    if (message.qrCodeUrl !== "") {
      obj.qrCodeUrl = message.qrCodeUrl;
    }
    if (message.manualEntryCode !== "") {
      obj.manualEntryCode = message.manualEntryCode;
    }
    if (message.type !== 0) {
      obj.type = twoFactorTypeToJSON(message.type);
    }
    if (message.deliveryTarget !== "") {
      obj.deliveryTarget = message.deliveryTarget;
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Enable2FAResponse>, I>>(base?: I): Enable2FAResponse {
    return Enable2FAResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Enable2FAResponse>, I>>(object: I): Enable2FAResponse {
    const message = createBaseEnable2FAResponse();
    message.secret = object.secret ?? "";
    message.qrCodeUrl = object.qrCodeUrl ?? "";
    message.manualEntryCode = object.manualEntryCode ?? "";
    message.type = object.type ?? 0;
    message.deliveryTarget = object.deliveryTarget ?? "";
    message.expiresAt = object.expiresAt ?? undefined;
    return message;
  },
};

function createBaseDisable2FARequest(): Disable2FARequest {
  return { password: "", twoFactorCode: undefined };
}

export const Disable2FARequest: MessageFns<Disable2FARequest> = {
  encode(message: Disable2FARequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.password !== "") {
      writer.uint32(10).string(message.password);
    }
    if (message.twoFactorCode !== undefined) {
      writer.uint32(18).string(message.twoFactorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disable2FARequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisable2FARequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.twoFactorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Disable2FARequest {
    return {
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      twoFactorCode: isSet(object.twoFactorCode) ? globalThis.String(object.twoFactorCode) : undefined,
    };
  },

  toJSON(message: Disable2FARequest): unknown {
    const obj: any = {};
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.twoFactorCode !== undefined) {
      obj.twoFactorCode = message.twoFactorCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Disable2FARequest>, I>>(base?: I): Disable2FARequest {
    return Disable2FARequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Disable2FARequest>, I>>(object: I): Disable2FARequest {
    const message = createBaseDisable2FARequest();
    message.password = object.password ?? "";
    message.twoFactorCode = object.twoFactorCode ?? undefined;
    return message;
  },
};

function createBaseVerify2FASetupRequest(): Verify2FASetupRequest {
  return { code: "", type: 0 };
}

export const Verify2FASetupRequest: MessageFns<Verify2FASetupRequest> = {
  encode(message: Verify2FASetupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Verify2FASetupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerify2FASetupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Verify2FASetupRequest {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      type: isSet(object.type) ? twoFactorTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Verify2FASetupRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.type !== 0) {
      obj.type = twoFactorTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Verify2FASetupRequest>, I>>(base?: I): Verify2FASetupRequest {
    return Verify2FASetupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Verify2FASetupRequest>, I>>(object: I): Verify2FASetupRequest {
    const message = createBaseVerify2FASetupRequest();
    message.code = object.code ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return {
    userId: "",
    name: "",
    email: "",
    phone: undefined,
    avatarUrl: "",
    emailVerified: false,
    phoneVerified: false,
    twoFactorEnabled: false,
    twoFactorType: 0,
    createdAt: undefined,
    updatedAt: undefined,
    lastLoginAt: undefined,
  };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(34).string(message.phone);
    }
    if (message.avatarUrl !== "") {
      writer.uint32(42).string(message.avatarUrl);
    }
    if (message.emailVerified !== false) {
      writer.uint32(48).bool(message.emailVerified);
    }
    if (message.phoneVerified !== false) {
      writer.uint32(56).bool(message.phoneVerified);
    }
    if (message.twoFactorEnabled !== false) {
      writer.uint32(64).bool(message.twoFactorEnabled);
    }
    if (message.twoFactorType !== 0) {
      writer.uint32(72).int32(message.twoFactorType);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).join();
    }
    if (message.lastLoginAt !== undefined) {
      Timestamp.encode(toTimestamp(message.lastLoginAt), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatarUrl = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.emailVerified = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.phoneVerified = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.twoFactorEnabled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.twoFactorType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.lastLoginAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      avatarUrl: isSet(object.avatarUrl) ? globalThis.String(object.avatarUrl) : "",
      emailVerified: isSet(object.emailVerified) ? globalThis.Boolean(object.emailVerified) : false,
      phoneVerified: isSet(object.phoneVerified) ? globalThis.Boolean(object.phoneVerified) : false,
      twoFactorEnabled: isSet(object.twoFactorEnabled) ? globalThis.Boolean(object.twoFactorEnabled) : false,
      twoFactorType: isSet(object.twoFactorType) ? twoFactorTypeFromJSON(object.twoFactorType) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      lastLoginAt: isSet(object.lastLoginAt) ? fromJsonTimestamp(object.lastLoginAt) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.avatarUrl !== "") {
      obj.avatarUrl = message.avatarUrl;
    }
    if (message.emailVerified !== false) {
      obj.emailVerified = message.emailVerified;
    }
    if (message.phoneVerified !== false) {
      obj.phoneVerified = message.phoneVerified;
    }
    if (message.twoFactorEnabled !== false) {
      obj.twoFactorEnabled = message.twoFactorEnabled;
    }
    if (message.twoFactorType !== 0) {
      obj.twoFactorType = twoFactorTypeToJSON(message.twoFactorType);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.lastLoginAt !== undefined) {
      obj.lastLoginAt = message.lastLoginAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? undefined;
    message.avatarUrl = object.avatarUrl ?? "";
    message.emailVerified = object.emailVerified ?? false;
    message.phoneVerified = object.phoneVerified ?? false;
    message.twoFactorEnabled = object.twoFactorEnabled ?? false;
    message.twoFactorType = object.twoFactorType ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.lastLoginAt = object.lastLoginAt ?? undefined;
    return message;
  },
};

function createBaseSessionInfo(): SessionInfo {
  return {
    user: undefined,
    sessionId: "",
    deviceInfo: "",
    ipAddress: "",
    userAgent: "",
    issuedAt: undefined,
    expiresAt: undefined,
    isMfaAuthenticated: false,
    permissions: [],
    metadata: {},
  };
}

export const SessionInfo: MessageFns<SessionInfo> = {
  encode(message: SessionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.deviceInfo !== "") {
      writer.uint32(26).string(message.deviceInfo);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(42).string(message.userAgent);
    }
    if (message.issuedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.issuedAt), writer.uint32(50).fork()).join();
    }
    if (message.expiresAt !== undefined) {
      Timestamp.encode(toTimestamp(message.expiresAt), writer.uint32(58).fork()).join();
    }
    if (message.isMfaAuthenticated !== false) {
      writer.uint32(64).bool(message.isMfaAuthenticated);
    }
    for (const v of message.permissions) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SessionInfo_MetadataEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceInfo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.issuedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expiresAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isMfaAuthenticated = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SessionInfo_MetadataEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.metadata[entry10.key] = entry10.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      deviceInfo: isSet(object.deviceInfo) ? globalThis.String(object.deviceInfo) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      issuedAt: isSet(object.issuedAt) ? fromJsonTimestamp(object.issuedAt) : undefined,
      expiresAt: isSet(object.expiresAt) ? fromJsonTimestamp(object.expiresAt) : undefined,
      isMfaAuthenticated: isSet(object.isMfaAuthenticated) ? globalThis.Boolean(object.isMfaAuthenticated) : false,
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SessionInfo): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.deviceInfo !== "") {
      obj.deviceInfo = message.deviceInfo;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.issuedAt !== undefined) {
      obj.issuedAt = message.issuedAt.toISOString();
    }
    if (message.expiresAt !== undefined) {
      obj.expiresAt = message.expiresAt.toISOString();
    }
    if (message.isMfaAuthenticated !== false) {
      obj.isMfaAuthenticated = message.isMfaAuthenticated;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionInfo>, I>>(base?: I): SessionInfo {
    return SessionInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionInfo>, I>>(object: I): SessionInfo {
    const message = createBaseSessionInfo();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    message.sessionId = object.sessionId ?? "";
    message.deviceInfo = object.deviceInfo ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.issuedAt = object.issuedAt ?? undefined;
    message.expiresAt = object.expiresAt ?? undefined;
    message.isMfaAuthenticated = object.isMfaAuthenticated ?? false;
    message.permissions = object.permissions?.map((e) => e) || [];
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSessionInfo_MetadataEntry(): SessionInfo_MetadataEntry {
  return { key: "", value: "" };
}

export const SessionInfo_MetadataEntry: MessageFns<SessionInfo_MetadataEntry> = {
  encode(message: SessionInfo_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionInfo_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionInfo_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionInfo_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SessionInfo_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionInfo_MetadataEntry>, I>>(base?: I): SessionInfo_MetadataEntry {
    return SessionInfo_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SessionInfo_MetadataEntry>, I>>(object: I): SessionInfo_MetadataEntry {
    const message = createBaseSessionInfo_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { currentPassword: "", newPassword: "", twoFactorCode: undefined };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentPassword !== "") {
      writer.uint32(10).string(message.currentPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    if (message.twoFactorCode !== undefined) {
      writer.uint32(26).string(message.twoFactorCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currentPassword = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.twoFactorCode = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      currentPassword: isSet(object.currentPassword) ? globalThis.String(object.currentPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
      twoFactorCode: isSet(object.twoFactorCode) ? globalThis.String(object.twoFactorCode) : undefined,
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.currentPassword !== "") {
      obj.currentPassword = message.currentPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    if (message.twoFactorCode !== undefined) {
      obj.twoFactorCode = message.twoFactorCode;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.currentPassword = object.currentPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    message.twoFactorCode = object.twoFactorCode ?? undefined;
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseResetPasswordRequest(): ResetPasswordRequest {
  return { token: "", newPassword: "" };
}

export const ResetPasswordRequest: MessageFns<ResetPasswordRequest> = {
  encode(message: ResetPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.newPassword !== "") {
      writer.uint32(18).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPasswordRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ResetPasswordRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(base?: I): ResetPasswordRequest {
    return ResetPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPasswordRequest>, I>>(object: I): ResetPasswordRequest {
    const message = createBaseResetPasswordRequest();
    message.token = object.token ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseVerifyAccountRequest(): VerifyAccountRequest {
  return { token: "", type: 0 };
}

export const VerifyAccountRequest: MessageFns<VerifyAccountRequest> = {
  encode(message: VerifyAccountRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyAccountRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyAccountRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      type: isSet(object.type) ? verificationTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: VerifyAccountRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.type !== 0) {
      obj.type = verificationTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(base?: I): VerifyAccountRequest {
    return VerifyAccountRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyAccountRequest>, I>>(object: I): VerifyAccountRequest {
    const message = createBaseVerifyAccountRequest();
    message.token = object.token ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseResendVerificationRequest(): ResendVerificationRequest {
  return { type: 0, email: undefined, phone: undefined };
}

export const ResendVerificationRequest: MessageFns<ResendVerificationRequest> = {
  encode(message: ResendVerificationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.email !== undefined) {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(26).string(message.phone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResendVerificationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResendVerificationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResendVerificationRequest {
    return {
      type: isSet(object.type) ? verificationTypeFromJSON(object.type) : 0,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
    };
  },

  toJSON(message: ResendVerificationRequest): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = verificationTypeToJSON(message.type);
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResendVerificationRequest>, I>>(base?: I): ResendVerificationRequest {
    return ResendVerificationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResendVerificationRequest>, I>>(object: I): ResendVerificationRequest {
    const message = createBaseResendVerificationRequest();
    message.type = object.type ?? 0;
    message.email = object.email ?? undefined;
    message.phone = object.phone ?? undefined;
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest: MessageFns<RefreshTokenRequest> = {
  encode(message: RefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: RefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(base?: I): RefreshTokenRequest {
    return RefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshTokenRequest>, I>>(object: I): RefreshTokenRequest {
    const message = createBaseRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseDeviceInfo(): DeviceInfo {
  return { deviceId: "", name: "", type: "", os: "", browser: "", lastActive: undefined, isCurrent: false };
}

export const DeviceInfo: MessageFns<DeviceInfo> = {
  encode(message: DeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.os !== "") {
      writer.uint32(34).string(message.os);
    }
    if (message.browser !== "") {
      writer.uint32(42).string(message.browser);
    }
    if (message.lastActive !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActive), writer.uint32(50).fork()).join();
    }
    if (message.isCurrent !== false) {
      writer.uint32(56).bool(message.isCurrent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.os = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.browser = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastActive = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isCurrent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceInfo {
    return {
      deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      os: isSet(object.os) ? globalThis.String(object.os) : "",
      browser: isSet(object.browser) ? globalThis.String(object.browser) : "",
      lastActive: isSet(object.lastActive) ? fromJsonTimestamp(object.lastActive) : undefined,
      isCurrent: isSet(object.isCurrent) ? globalThis.Boolean(object.isCurrent) : false,
    };
  },

  toJSON(message: DeviceInfo): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.os !== "") {
      obj.os = message.os;
    }
    if (message.browser !== "") {
      obj.browser = message.browser;
    }
    if (message.lastActive !== undefined) {
      obj.lastActive = message.lastActive.toISOString();
    }
    if (message.isCurrent !== false) {
      obj.isCurrent = message.isCurrent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeviceInfo>, I>>(base?: I): DeviceInfo {
    return DeviceInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeviceInfo>, I>>(object: I): DeviceInfo {
    const message = createBaseDeviceInfo();
    message.deviceId = object.deviceId ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.os = object.os ?? "";
    message.browser = object.browser ?? "";
    message.lastActive = object.lastActive ?? undefined;
    message.isCurrent = object.isCurrent ?? false;
    return message;
  },
};

function createBaseGetDevicesResponse(): GetDevicesResponse {
  return { devices: [] };
}

export const GetDevicesResponse: MessageFns<GetDevicesResponse> = {
  encode(message: GetDevicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.devices) {
      DeviceInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDevicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDevicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.devices.push(DeviceInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDevicesResponse {
    return {
      devices: globalThis.Array.isArray(object?.devices) ? object.devices.map((e: any) => DeviceInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetDevicesResponse): unknown {
    const obj: any = {};
    if (message.devices?.length) {
      obj.devices = message.devices.map((e) => DeviceInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDevicesResponse>, I>>(base?: I): GetDevicesResponse {
    return GetDevicesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDevicesResponse>, I>>(object: I): GetDevicesResponse {
    const message = createBaseGetDevicesResponse();
    message.devices = object.devices?.map((e) => DeviceInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRevokeDeviceRequest(): RevokeDeviceRequest {
  return { deviceId: "" };
}

export const RevokeDeviceRequest: MessageFns<RevokeDeviceRequest> = {
  encode(message: RevokeDeviceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceId !== "") {
      writer.uint32(10).string(message.deviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeDeviceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeDeviceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeDeviceRequest {
    return { deviceId: isSet(object.deviceId) ? globalThis.String(object.deviceId) : "" };
  },

  toJSON(message: RevokeDeviceRequest): unknown {
    const obj: any = {};
    if (message.deviceId !== "") {
      obj.deviceId = message.deviceId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeDeviceRequest>, I>>(base?: I): RevokeDeviceRequest {
    return RevokeDeviceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeDeviceRequest>, I>>(object: I): RevokeDeviceRequest {
    const message = createBaseRevokeDeviceRequest();
    message.deviceId = object.deviceId ?? "";
    return message;
  },
};

function createBaseSecurityEvent(): SecurityEvent {
  return { eventId: "", type: "", description: "", ipAddress: "", userAgent: "", occurredAt: undefined, metadata: {} };
}

export const SecurityEvent: MessageFns<SecurityEvent> = {
  encode(message: SecurityEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(42).string(message.userAgent);
    }
    if (message.occurredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.occurredAt), writer.uint32(50).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SecurityEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.occurredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = SecurityEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.metadata[entry7.key] = entry7.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityEvent {
    return {
      eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      occurredAt: isSet(object.occurredAt) ? fromJsonTimestamp(object.occurredAt) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SecurityEvent): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.occurredAt !== undefined) {
      obj.occurredAt = message.occurredAt.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityEvent>, I>>(base?: I): SecurityEvent {
    return SecurityEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityEvent>, I>>(object: I): SecurityEvent {
    const message = createBaseSecurityEvent();
    message.eventId = object.eventId ?? "";
    message.type = object.type ?? "";
    message.description = object.description ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.occurredAt = object.occurredAt ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSecurityEvent_MetadataEntry(): SecurityEvent_MetadataEntry {
  return { key: "", value: "" };
}

export const SecurityEvent_MetadataEntry: MessageFns<SecurityEvent_MetadataEntry> = {
  encode(message: SecurityEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SecurityEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecurityEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SecurityEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SecurityEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SecurityEvent_MetadataEntry>, I>>(base?: I): SecurityEvent_MetadataEntry {
    return SecurityEvent_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SecurityEvent_MetadataEntry>, I>>(object: I): SecurityEvent_MetadataEntry {
    const message = createBaseSecurityEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetSecurityEventsRequest(): GetSecurityEventsRequest {
  return { page: 0, pageSize: 0, fromDate: undefined, toDate: undefined };
}

export const GetSecurityEventsRequest: MessageFns<GetSecurityEventsRequest> = {
  encode(message: GetSecurityEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.fromDate !== undefined) {
      Timestamp.encode(toTimestamp(message.fromDate), writer.uint32(26).fork()).join();
    }
    if (message.toDate !== undefined) {
      Timestamp.encode(toTimestamp(message.toDate), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSecurityEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecurityEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fromDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecurityEventsRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      fromDate: isSet(object.fromDate) ? fromJsonTimestamp(object.fromDate) : undefined,
      toDate: isSet(object.toDate) ? fromJsonTimestamp(object.toDate) : undefined,
    };
  },

  toJSON(message: GetSecurityEventsRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.fromDate !== undefined) {
      obj.fromDate = message.fromDate.toISOString();
    }
    if (message.toDate !== undefined) {
      obj.toDate = message.toDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecurityEventsRequest>, I>>(base?: I): GetSecurityEventsRequest {
    return GetSecurityEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecurityEventsRequest>, I>>(object: I): GetSecurityEventsRequest {
    const message = createBaseGetSecurityEventsRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.fromDate = object.fromDate ?? undefined;
    message.toDate = object.toDate ?? undefined;
    return message;
  },
};

function createBaseGetSecurityEventsResponse(): GetSecurityEventsResponse {
  return { events: [], total: 0, page: 0, pageSize: 0 };
}

export const GetSecurityEventsResponse: MessageFns<GetSecurityEventsResponse> = {
  encode(message: GetSecurityEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      SecurityEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(32).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSecurityEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSecurityEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(SecurityEvent.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSecurityEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events) ? object.events.map((e: any) => SecurityEvent.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: GetSecurityEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => SecurityEvent.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSecurityEventsResponse>, I>>(base?: I): GetSecurityEventsResponse {
    return GetSecurityEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSecurityEventsResponse>, I>>(object: I): GetSecurityEventsResponse {
    const message = createBaseGetSecurityEventsResponse();
    message.events = object.events?.map((e) => SecurityEvent.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBaseGenericMessage(): GenericMessage {
  return { message: "", details: {} };
}

export const GenericMessage: MessageFns<GenericMessage> = {
  encode(message: GenericMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      GenericMessage_DetailsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GenericMessage_DetailsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.details[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericMessage {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: isObject(object.details)
        ? Object.entries(object.details).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GenericMessage): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details) {
      const entries = Object.entries(message.details);
      if (entries.length > 0) {
        obj.details = {};
        entries.forEach(([k, v]) => {
          obj.details[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericMessage>, I>>(base?: I): GenericMessage {
    return GenericMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericMessage>, I>>(object: I): GenericMessage {
    const message = createBaseGenericMessage();
    message.message = object.message ?? "";
    message.details = Object.entries(object.details ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGenericMessage_DetailsEntry(): GenericMessage_DetailsEntry {
  return { key: "", value: "" };
}

export const GenericMessage_DetailsEntry: MessageFns<GenericMessage_DetailsEntry> = {
  encode(message: GenericMessage_DetailsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericMessage_DetailsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericMessage_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericMessage_DetailsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GenericMessage_DetailsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericMessage_DetailsEntry>, I>>(base?: I): GenericMessage_DetailsEntry {
    return GenericMessage_DetailsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericMessage_DetailsEntry>, I>>(object: I): GenericMessage_DetailsEntry {
    const message = createBaseGenericMessage_DetailsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  /** Public endpoints */
  login: {
    path: "/auth.v1.AuthService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest): Buffer => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): LoginRequest => LoginRequest.decode(value),
    responseSerialize: (value: LoginResponse): Buffer => Buffer.from(LoginResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): LoginResponse => LoginResponse.decode(value),
  },
  signup: {
    path: "/auth.v1.AuthService/Signup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SignupRequest): Buffer => Buffer.from(SignupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SignupRequest => SignupRequest.decode(value),
    responseSerialize: (value: SignupResponse): Buffer => Buffer.from(SignupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SignupResponse => SignupResponse.decode(value),
  },
  refreshToken: {
    path: "/auth.v1.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest): Buffer => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RefreshTokenRequest => RefreshTokenRequest.decode(value),
    responseSerialize: (value: AuthTokens): Buffer => Buffer.from(AuthTokens.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthTokens => AuthTokens.decode(value),
  },
  /** 2FA verification */
  verify2Fa: {
    path: "/auth.v1.AuthService/Verify2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Verify2FARequest): Buffer => Buffer.from(Verify2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Verify2FARequest => Verify2FARequest.decode(value),
    responseSerialize: (value: AuthTokens): Buffer => Buffer.from(AuthTokens.encode(value).finish()),
    responseDeserialize: (value: Buffer): AuthTokens => AuthTokens.decode(value),
  },
  /** Authenticated endpoints (JWT via metadata) */
  logout: {
    path: "/auth.v1.AuthService/Logout",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  changePassword: {
    path: "/auth.v1.AuthService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest): Buffer =>
      Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ChangePasswordRequest => ChangePasswordRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  getSession: {
    path: "/auth.v1.AuthService/GetSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: SessionInfo): Buffer => Buffer.from(SessionInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer): SessionInfo => SessionInfo.decode(value),
  },
  /** 2FA management (authenticated) */
  enable2Fa: {
    path: "/auth.v1.AuthService/Enable2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Enable2FARequest): Buffer => Buffer.from(Enable2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Enable2FARequest => Enable2FARequest.decode(value),
    responseSerialize: (value: Enable2FAResponse): Buffer => Buffer.from(Enable2FAResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): Enable2FAResponse => Enable2FAResponse.decode(value),
  },
  disable2Fa: {
    path: "/auth.v1.AuthService/Disable2FA",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Disable2FARequest): Buffer => Buffer.from(Disable2FARequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Disable2FARequest => Disable2FARequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  verify2FaSetup: {
    path: "/auth.v1.AuthService/Verify2FASetup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Verify2FASetupRequest): Buffer =>
      Buffer.from(Verify2FASetupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): Verify2FASetupRequest => Verify2FASetupRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Verification endpoints */
  verifyAccount: {
    path: "/auth.v1.AuthService/VerifyAccount",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyAccountRequest): Buffer => Buffer.from(VerifyAccountRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VerifyAccountRequest => VerifyAccountRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  resendVerification: {
    path: "/auth.v1.AuthService/ResendVerification",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResendVerificationRequest): Buffer =>
      Buffer.from(ResendVerificationRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResendVerificationRequest => ResendVerificationRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Password recovery */
  forgotPassword: {
    path: "/auth.v1.AuthService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest): Buffer =>
      Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ForgotPasswordRequest => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  resetPassword: {
    path: "/auth.v1.AuthService/ResetPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ResetPasswordRequest): Buffer => Buffer.from(ResetPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ResetPasswordRequest => ResetPasswordRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  /** Public endpoints */
  login: handleUnaryCall<LoginRequest, LoginResponse>;
  signup: handleUnaryCall<SignupRequest, SignupResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, AuthTokens>;
  /** 2FA verification */
  verify2Fa: handleUnaryCall<Verify2FARequest, AuthTokens>;
  /** Authenticated endpoints (JWT via metadata) */
  logout: handleUnaryCall<Empty, Empty>;
  changePassword: handleUnaryCall<ChangePasswordRequest, Empty>;
  getSession: handleUnaryCall<Empty, SessionInfo>;
  /** 2FA management (authenticated) */
  enable2Fa: handleUnaryCall<Enable2FARequest, Enable2FAResponse>;
  disable2Fa: handleUnaryCall<Disable2FARequest, Empty>;
  verify2FaSetup: handleUnaryCall<Verify2FASetupRequest, Empty>;
  /** Verification endpoints */
  verifyAccount: handleUnaryCall<VerifyAccountRequest, Empty>;
  resendVerification: handleUnaryCall<ResendVerificationRequest, Empty>;
  /** Password recovery */
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, Empty>;
  resetPassword: handleUnaryCall<ResetPasswordRequest, Empty>;
}

export interface AuthServiceClient extends Client {
  /** Public endpoints */
  login(
    request: LoginRequest,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  login(
    request: LoginRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  signup(
    request: SignupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SignupResponse) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  /** 2FA verification */
  verify2Fa(
    request: Verify2FARequest,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  verify2Fa(
    request: Verify2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  verify2Fa(
    request: Verify2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: AuthTokens) => void,
  ): ClientUnaryCall;
  /** Authenticated endpoints (JWT via metadata) */
  logout(request: Empty, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  logout(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  logout(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  getSession(request: Empty, callback: (error: ServiceError | null, response: SessionInfo) => void): ClientUnaryCall;
  getSession(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SessionInfo) => void,
  ): ClientUnaryCall;
  getSession(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SessionInfo) => void,
  ): ClientUnaryCall;
  /** 2FA management (authenticated) */
  enable2Fa(
    request: Enable2FARequest,
    callback: (error: ServiceError | null, response: Enable2FAResponse) => void,
  ): ClientUnaryCall;
  enable2Fa(
    request: Enable2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Enable2FAResponse) => void,
  ): ClientUnaryCall;
  enable2Fa(
    request: Enable2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Enable2FAResponse) => void,
  ): ClientUnaryCall;
  disable2Fa(
    request: Disable2FARequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  disable2Fa(
    request: Disable2FARequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  disable2Fa(
    request: Disable2FARequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verify2FaSetup(
    request: Verify2FASetupRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verify2FaSetup(
    request: Verify2FASetupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verify2FaSetup(
    request: Verify2FASetupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Verification endpoints */
  verifyAccount(
    request: VerifyAccountRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  verifyAccount(
    request: VerifyAccountRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resendVerification(
    request: ResendVerificationRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resendVerification(
    request: ResendVerificationRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resendVerification(
    request: ResendVerificationRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Password recovery */
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  resetPassword(
    request: ResetPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const AuthServiceClient = makeGenericClientConstructor(AuthServiceService, "auth.v1.AuthService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AuthServiceClient;
  service: typeof AuthServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
